<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Project Rushing - Hold Notes + Restored Songs</title>
  <style>
    html,body { height:100%; margin:0; background:#000; color:#fff; font-family:Arial, sans-serif; }
    canvas { display:block; margin:0 auto; background:#000; }
    #ui { position:fixed; left:625px; top:550px; color:#fff; font-size:40px; z-index:10; }
    .popup { position:fixed; left:50%; top:80%; transform:translateX(-50%); padding:12px 18px;
      background:rgba(255,255,255,0.06); color:#fff; font-size:32px; border-radius:8px; pointer-events:none; z-index:20; text-align:center; }
    #songSelect { position:fixed; left:20px; top:20px; z-index:30; background:rgba(255,255,255,0.03);
      padding:12px; border-radius:8px; width:360px; }
    .songItem { margin-bottom:10px; display:flex; justify-content:space-between; align-items:center; }
    .songItem button { padding:6px 12px; font-size:16px; cursor:pointer; }
    #currentSong { position:fixed; left:20px; top:300px; font-size:18px; color:#ccc; }
    #scoreUI { position:fixed; left:20px; bottom:20px; color:#fff; z-index:40; font-size:14px; }
    #scoreUI small { color:#7f7; }
  </style>
</head>
<body>
  <div id="songSelect">
    <div style="font-weight:bold; font-size:18px; margin-bottom:8px;">Select a song</div>
    <div id="songsList"></div>
  </div>

  <div id="ui"><strong>:</strong> <span id="combo">0</span></div>
  <div id="currentSong">No song loaded</div>
  <canvas id="game" width="800" height="600"></canvas>

  <div id="scoreUI">
    <div><strong>Score:</strong> <span id="basePercent">0.00%</span> <small>(+<span id="bonusPercent">0.00%</span>)</small></div>
    <div><strong>Total:</strong> <span id="totalPercent">0.00%</span></div>
    <div style="font-size:13px; color:#aaa;">Notes: <span id="totalNotes">0</span> | ACEs: <span id="aceCount">0</span></div>
  </div>

  <audio id="music" preload="auto"></audio>

<script>
// Canvas + constants
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const WIDTH = canvas.width, HEIGHT = canvas.height;
const JUDGE_X = 100;
const NOTE_RADIUS = 18;
let NOTE_Y = 350, NOTE_Y2 = 500;

// Runtime
let NOTESPEED = 10; // px/frame default; overridden per-song
let notes = []; // array of note objects (tap or hold)

// Scoring
let totalNotes = 0, basePoints = 0, aceCount = 0, missCount = 0;

// UI refs
const comboEl = document.getElementById('combo');
const basePercentEl = document.getElementById('basePercent');
const bonusPercentEl = document.getElementById('bonusPercent');
const totalPercentEl = document.getElementById('totalPercent');
const totalNotesEl = document.getElementById('totalNotes');
const aceCountEl = document.getElementById('aceCount');
const musicEl = document.getElementById('music');
const currentSongEl = document.getElementById('currentSong');

// Lane mapping
const LANE_KEY_MAP = { KeyD: 'L1', KeyF: 'L2', KeyJ: 'L3', KeyK: 'L4' };

// Hold/timing config
const RELEASE_GRACE_FRAMES = 2; // tiny grace before tail
const LEFT_MISS_MULT = 11;      // left miss threshold multiplier
function releaseGracePx() { return Math.max(1, RELEASE_GRACE_FRAMES * Math.max(1, NOTESPEED)); }

// Songs (restored), song1 points to local file name
const songs = {
  song1: {
    id: 'song1',
    title: 'World Reset',
    audioSrc: 'WORLD RESET.mp3',
    NOTESPEED: 19.6078431,
    notesData: [
      { type: 'tap', x: 1680, y: NOTE_Y, lane: 'L1' },
      { type: 'tap', x: 1680 + 4.5 * 19.6078431, y: NOTE_Y, lane: 'L1' },
      { type: 'tap', x: 1680 + 9 * 19.6078431, y: NOTE_Y, lane: 'L1' },
      { type: 'tap', x: 1680 + 13.5 * 19.6078431, y: NOTE_Y, lane: 'L1' },
      { type: 'hold', x: 1680 + 18 * 19.6078431, y: NOTE_Y, lengthPx: 9 * 19.6078431, lane: 'L1' }
    ]
  },
  song2: {
    id: 'song2',
    title: 'songname2 - DoubleLine',
    audioSrc: 'audio/song2.mp3',
    NOTESPEED: 15,
    notesData: [
      { type: 'tap', x: 440, y: NOTE_Y, lane: 'L1' },
      { type: 'tap', x: 440, y: NOTE_Y2, lane: 'L2' },
      { type: 'tap', x: 560, y: NOTE_Y, lane: 'L1' },
      { type: 'tap', x: 680, y: NOTE_Y2, lane: 'L4' },
      { type: 'tap', x: 820, y: NOTE_Y, lane: 'L3' }
    ]
  },
  song3: {
    id: 'song3',
    title: 'songname3 - Electro Bullet',
    audioSrc: 'audio/song3.mp3',
    NOTESPEED: 20,
    notesData: [
      { type: 'tap', x: 500, y: NOTE_Y, lane: 'L1' },
      { type: 'tap', x: 560, y: NOTE_Y, lane: 'L1' },
      { type: 'tap', x: 620, y: NOTE_Y, lane: 'L1' },
      { type: 'tap', x: 680, y: NOTE_Y, lane: 'L1' },
      { type: 'tap', x: 740, y: NOTE_Y, lane: 'L1' },
      { type: 'tap', x: 820, y: NOTE_Y, lane: 'L1' }
    ]
  }
};

// Expose per-song constants (optional)
const song1NOTESPEED = songs.song1.NOTESPEED, song1notes = songs.song1.notesData;
const song2NOTESPEED = songs.song2.NOTESPEED, song2notes = songs.song2.notesData;
const song3NOTESPEED = songs.song3.NOTESPEED, song3notes = songs.song3.notesData;

// Build UI
const songsList = document.getElementById('songsList');
function createSongButtons() {
  Object.values(songs).forEach(s => {
    const row = document.createElement('div'); row.className = 'songItem';
    const label = document.createElement('div'); label.textContent = s.title; label.style.flex = '1';
    const btn = document.createElement('button'); btn.textContent = 'Play'; btn.onclick = () => selectSong(s.id);
    row.appendChild(label); row.appendChild(btn); songsList.appendChild(row);
  });
}

// Popup
let popupEl = null, popupTimer = null;
function showTemporaryText(text, ms = 700) {
  if (popupEl) { popupEl.remove(); popupEl = null; if (popupTimer) clearTimeout(popupTimer); popupTimer = null; }
  popupEl = document.createElement('div'); popupEl.className = 'popup'; popupEl.textContent = text;
  document.body.appendChild(popupEl);
  popupTimer = setTimeout(() => { if (popupEl) { popupEl.remove(); popupEl = null; } popupTimer = null; }, ms);
}

// Scoring helpers
function initScoringForSong(arr) {
  totalNotes = arr.reduce((acc, n) => acc + (n.type === 'hold' ? 2 : 1), 0);
  basePoints = 0; aceCount = 0; missCount = 0;
  updateScoreUI();
  totalNotesEl.textContent = totalNotes; aceCountEl.textContent = aceCount;
}
function updateScoreUI() {
  const basePercent = totalNotes > 0 ? (basePoints / totalNotes) * 100 : 0;
  const bonusPercent = totalNotes > 0 ? (aceCount / totalNotes) * 1 : 0;
  const totalPercent = basePercent + bonusPercent;
  basePercentEl.textContent = basePercent.toFixed(2) + '%';
  bonusPercentEl.textContent = bonusPercent.toFixed(2) + '%';
  totalPercentEl.textContent = totalPercent.toFixed(2) + '%';
  aceCountEl.textContent = aceCount;
}

// Note helpers (holds require real hold)
function cloneNotes(arr) {
  return arr.map(n => {
    if (n.type === 'hold') {
      return {
        type: 'hold',
        x: n.x, y: n.y,
        lengthPx: n.lengthPx || 300,
        lane: n.lane || null,
        active: true,
        headHit: false,
        held: false,        // true while key physically held
        allowFinish: false, // tiny grace allows finish if released very near tail
        releasedEarly: false,
        tailConsumed: false,
        invalid: false
      };
    } else {
      return { type: 'tap', x: n.x, y: n.y, lane: n.lane || null, active: true, invalid: false };
    }
  });
}
function tailX(n) { return n.x + (n.lengthPx || 0); }

// Judgement windows
function getJudgement(x) {
  if (x >= (JUDGE_X - 12 * NOTESPEED) && x < (JUDGE_X - 8 * NOTESPEED)) return 'MISS';
  if (x >= (JUDGE_X - 8 * NOTESPEED) && x < (JUDGE_X - 5 * NOTESPEED)) return 'L-GOOD';
  if (x >= (JUDGE_X - 5 * NOTESPEED) && x < (JUDGE_X - 1 * NOTESPEED)) return 'L-PERFECT';
  if (x >= (JUDGE_X - 1 * NOTESPEED) && x <= (JUDGE_X + 1 * NOTESPEED)) return 'ACE';
  if (x > (JUDGE_X + 1 * NOTESPEED) && x <= (JUDGE_X + 5 * NOTESPEED)) return 'E-PERFECT';
  if (x > (JUDGE_X + 5 * NOTESPEED) && x <= (JUDGE_X + 8 * NOTESPEED)) return 'E-GOOD';
  if (x > (JUDGE_X + 8 * NOTESPEED) && x <= (JUDGE_X + 12 * NOTESPEED)) return 'MISS';
  return null;
}

// apply judgement
function applyJudgement(j) {
  let point = 0;
  if (j === 'ACE' || j === 'L-PERFECT' || j === 'E-PERFECT') point = 1;
  else if (j === 'L-GOOD' || j === 'E-GOOD') point = 0.5;
  else point = 0;
  if (j === 'ACE') aceCount += 1;
  if (point === 0) missCount += 1;
  basePoints += point;
  updateScoreUI();
}

// lane hold state
const laneHoldState = {};

// Input handling (prevent auto-repeat)
const keyLastTime = {};
const PER_KEY_COOLDOWN_MS = 20;
const keysDown = new Set();

function handleKeydown(e) {
  const code = e.code || e.key;
  if (e.repeat) return;
  const now = performance.now();
  if (keyLastTime[code] && (now - keyLastTime[code] < PER_KEY_COOLDOWN_MS)) return;
  keyLastTime[code] = now;
  if (keysDown.has(code)) return;
  keysDown.add(code);

  const lane = LANE_KEY_MAP[code] || null;

  // lane-aware candidate search (heads only for holds)
  let candidate = null, bestDist = Infinity;
  for (let i = 0; i < notes.length; i++) {
    const n = notes[i];
    if (!n || n.invalid) continue;
    if (n.type === 'hold') {
      if (!n.active) continue;
      if (n.tailConsumed) continue;
      if (lane && n.lane && n.lane !== lane) continue;
      const dist = Math.abs(n.x - JUDGE_X);
      if (dist < bestDist) { bestDist = dist; candidate = n; }
      continue;
    }
    if (!n.active) continue;
    if (lane && n.lane && n.lane !== lane) continue;
    const dist = Math.abs(n.x - JUDGE_X);
    if (dist < bestDist) { bestDist = dist; candidate = n; }
  }

  if (!candidate) return;
  if (candidate.x < (JUDGE_X - 25 * NOTESPEED) || candidate.x > (JUDGE_X + 25 * NOTESPEED)) return;

  if (candidate.type === 'tap') {
    const j = getJudgement(candidate.x);
    candidate.active = false;
    if (j === 'MISS' || j === null) {
      combo = 0; comboEl.textContent = combo;
      requestAnimationFrame(() => showTemporaryText('MISS', 900));
    } else {
      combo += 1; comboEl.textContent = combo;
      requestAnimationFrame(() => showTemporaryText(j, 900));
    }
    applyJudgement(j);
    return;
  }

  // hold head
  if (candidate.type === 'hold') {
    if (!candidate.active) return;
    const j = getJudgement(candidate.x);
    candidate.active = false; // consume head
    if (j === 'MISS' || j === null) {
      candidate.headHit = false; candidate.tailConsumed = true; candidate.releasedEarly = true; candidate.invalid = true;
      combo = 0; comboEl.textContent = combo; requestAnimationFrame(() => showTemporaryText('MISS', 900));
      applyJudgement('MISS');
    } else {
      candidate.headHit = true; candidate.held = true; candidate.allowFinish = false; candidate.releasedEarly = false;
      candidate.headHitTime = performance.now();
      laneHoldState[candidate.lane] = candidate;
      combo += 1; comboEl.textContent = combo; requestAnimationFrame(() => showTemporaryText(j, 900));
      applyJudgement(j);
    }
  }
}

function handleKeyup(e) {
  const code = e.code || e.key;
  if (keysDown.has(code)) keysDown.delete(code);

  const lane = LANE_KEY_MAP[code] || null;
  if (!lane) return;
  const heldNote = laneHoldState[lane];
  if (!heldNote) return;

  if (heldNote.tailConsumed) { laneHoldState[lane] = null; return; }

  const tX = tailX(heldNote);
  const tailDist = tX - JUDGE_X;

  // tiny grace allows finish if release is very near tail
  if (tailDist <= releaseGracePx()) {
    heldNote.allowFinish = true;
    heldNote.held = false;
    heldNote.releasedEarly = false;
    laneHoldState[lane] = null;
    return;
  }

  // otherwise early release -> miss later
  heldNote.held = false;
  heldNote.allowFinish = false;
  heldNote.releasedEarly = true;
  laneHoldState[lane] = null;
}

window.removeEventListener('keydown', handleKeydown);
window.removeEventListener('keyup', handleKeyup);
window.addEventListener('keydown', handleKeydown);
window.addEventListener('keyup', handleKeyup);

function forceShowMiss() {
  combo = 0; comboEl.textContent = combo;
  requestAnimationFrame(() => showTemporaryText('MISS'));
}

function update() {
  const leftMissLimit = JUDGE_X - LEFT_MISS_MULT * NOTESPEED;
  for (let i = 0; i < notes.length; i++) {
    const n = notes[i];
    if (!n) continue;

    if (n.type === 'tap') {
      if (!n.active) continue;
      n.x -= NOTESPEED;
      if (n.x <= 0 || n.x <= leftMissLimit) {
        n.active = false; n.invalid = true; missCount += 1; forceShowMiss(); updateScoreUI();
      }
      continue;
    }

    // hold logic
    if (n.type === 'hold') {
      n.x -= NOTESPEED;

      if (!n.headHit && n.x <= leftMissLimit) {
        n.active = false; n.tailConsumed = true; n.releasedEarly = true; n.invalid = true;
        missCount += 1; forceShowMiss(); updateScoreUI();
        if (n.lane && laneHoldState[n.lane] === n) laneHoldState[n.lane] = null;
        continue;
      }

      if (!n.tailConsumed && tailX(n) <= JUDGE_X) {
        n.tailConsumed = true; // resolve once

        if (!n.headHit) {
          applyJudgement('MISS'); combo = 0; comboEl.textContent = combo; missCount += 1;
          requestAnimationFrame(() => showTemporaryText('MISS'));
          if (n.lane && laneHoldState[n.lane] === n) laneHoldState[n.lane] = null;
          continue;
        }

        // success requires headHit AND (still held OR allowFinish)
        if (n.held === true || n.allowFinish === true) {
          applyJudgement('ACE'); combo += 1; comboEl.textContent = combo;
          requestAnimationFrame(() => showTemporaryText('ACE'));
        } else {
          applyJudgement('MISS'); combo = 0; comboEl.textContent = combo;
          requestAnimationFrame(() => showTemporaryText('MISS'));
        }

        if (n.lane && laneHoldState[n.lane] === n) laneHoldState[n.lane] = null;
      }
    }
  }

  // optional cleanup:
  // notes = notes.filter(n => !(n.type === 'tap' && !n.active) && !(n.type === 'hold' && n.tailConsumed));
}

function draw() {
  ctx.clearRect(0, 0, WIDTH, HEIGHT);
  ctx.strokeStyle = '#fff'; ctx.lineWidth = 4;
  ctx.beginPath(); ctx.moveTo(JUDGE_X, HEIGHT); ctx.lineTo(JUDGE_X, 80); ctx.stroke();

  notes.forEach(n => {
    if (!n) return;
    if (n.type === 'hold') {
      ctx.strokeStyle = '#4aa'; ctx.lineWidth = 6;
      ctx.beginPath(); const tail = tailX(n); ctx.moveTo(n.x, n.y); ctx.lineTo(tail, n.y); ctx.stroke();
      if (!n.tailConsumed) {
        ctx.strokeStyle = n.active ? '#fff' : '#777'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(n.x, n.y, NOTE_RADIUS, 0, Math.PI * 2); ctx.stroke();
        ctx.strokeStyle = '#fff'; ctx.beginPath(); ctx.arc(tail, n.y, NOTE_RADIUS - 6, 0, Math.PI * 2); ctx.stroke();
      }
    } else {
      if (!n.active) return;
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(n.x, n.y, NOTE_RADIUS, 0, Math.PI * 2); ctx.stroke();
    }
  });
}

// Combo, loop (30 FPS cap)
let combo = 0;
let running = false;
const TARGET_FPS = 30;
const FRAME_INTERVAL_MS = 1000 / TARGET_FPS;
let lastFrameTime = performance.now();

function loop() {
  requestAnimationFrame(loop);
  const now = performance.now(); const dt = now - lastFrameTime;
  if (dt < FRAME_INTERVAL_MS) return;
  lastFrameTime += Math.floor(dt / FRAME_INTERVAL_MS) * FRAME_INTERVAL_MS;
  if (running) { update(); draw(); }
}
lastFrameTime = performance.now();
loop();

// Song select/start
function selectSong(id) {
  const s = songs[id]; if (!s) return;
  musicEl.pause(); musicEl.currentTime = 0;
  NOTESPEED = s.NOTESPEED;
  notes = cloneNotes(s.notesData);
  initScoringForSong(notes);
  if (s.audioSrc) { musicEl.src = s.audioSrc; musicEl.play().catch(() => showTemporaryText('Click to enable audio')); }
  else musicEl.src = '';
  combo = 0; comboEl.textContent = combo;
  running = true;
  currentSongEl.textContent = 'Loaded: ' + s.title;
  showTemporaryText('Loaded ' + s.title, 700);
}

createSongButtons();
window.startSongById = selectSong;
</script>
</body>
</html>
