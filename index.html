<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Project Rushing - Hold Notes + Restored Songs (fixed)</title>
<style>
html,body { height:100%; margin:0; background:#000; color:#fff; font-family:Arial, sans-serif; }
canvas { display:block; margin:0 auto; background:#000; }
#ui { position:fixed; left:625px; top:550px; color:#fff; font-size:40px; z-index: 10; }
.popup { position:fixed; left:50%; top:80%; transform:translateX(-50%); padding: 12px 18px;
background:rgba(255,255,255,0.06); color:#fff; font-size:32px; border-radius:8px;
pointer-events:none; z-index:20; text-align:center; }
#songSelect { position:fixed; left:20px; top:20px; z-index:30;
background:rgba(255,255,255,0.03);
padding:12px; border-radius:8px; width:360px; }
.songItem { margin-bottom:10px; display:flex; justify-content:space-between;
align-items:center; }
.songItem button { padding:6px 12px; font-size:16px; cursor:pointer; }
#currentSong { position:fixed; left:20px; top:300px; font-size:18px; color:#ccc; }
#scoreUI { position:fixed; left:20px; bottom:20px; color:#fff; z-index:40; font-size:14px; }
#scoreUI small { color:#7f7; }
</style>
</head>
<body>
<div id="songSelect">
  <div style="font-weight:bold; font-size:18px; margin-bottom:8px;">Select a song</div>
  <div id="songsList"></div>
</div>

<div id="ui"><strong> : </strong> <span id="combo">0</span></div>
<div id="currentSong">No song loaded</div>
<canvas id="game" width="800" height="600"></canvas>
<div id="scoreUI">
  <div><strong>Score : </strong> <span id="basePercent">0.00%</span> <small>(+<span id="bonusPercent">0.00%</span>)</small></div>
  <div><strong>Total : </strong> <span id="totalPercent">0.00%</span></div>
  <div style="font-size:13px; color:#aaa;">Notes: <span id="totalNotes">0</span> | ACEs: <span id="aceCount">0</span></div>
</div>
<audio id="music" preload="auto"></audio>

<script>
// --- constants / UI refs
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const WIDTH = canvas.width, HEIGHT = canvas.height;
const JUDGE_X = 100;
const NOTE_RADIUS = 18;
let NOTE_Y = 350, NOTE_Y2 = 450, NOTE_Y1=250

let NOTESPEED = 10;
let notes = [];

let totalNotes = 0, basePoints = 0, aceCount = 0, missCount = 0;

const comboEl = document.getElementById('combo');
const basePercentEl = document.getElementById('basePercent');
const bonusPercentEl = document.getElementById('bonusPercent');
const totalPercentEl = document.getElementById('totalPercent');
const totalNotesEl = document.getElementById('totalNotes');
const aceCountEl = document.getElementById('aceCount');
const musicEl = document.getElementById('music');
const currentSongEl = document.getElementById('currentSong');

const LANE_KEY_MAP = { KeyD: 'L1', KeyF: 'L2', KeyJ: 'L3', KeyK: 'L4' };

// --- songs (kept as in your file, trimmed here)
const songs = {
  song1: { id:'song1', title:'World Reset', audioSrc:'WORLD RESET.mp3', NOTESPEED:19.6078431,
    notesData:[
      { type:'tap', x:1680, y:NOTE_Y, lane:'L1' },
      { type:'tap', x:1680 + 5*19.6078431, y:NOTE_Y1, lane:'L1' },
      { type:'tap', x:1680 + 9*19.6078431, y:NOTE_Y1, lane:'L3' },
      { type:'tap', x:1680 + 13*19.6078431, y:NOTE_Y2, lane:'L3' },
      { type:'hold', x:1680 + 18*19.6078431, y:NOTE_Y, lengthPx:5*19.6078431, lane:'L2' },
      { type:'tap', x:1680+27*19.6078431, y:NOTE_Y, lane:'L2' },
      { type:'tap', x:1680+32*19.6078431, y:NOTE_Y1, lane:'L1' },
      { type:'tap', x:1680+36*19.6078431, y:NOTE_Y2, lane:'L3' },
      { type:'tap', x:1680+41*19.6078431, y:NOTE_Y2, lane:'L3' },
      { type:'tap', x:1680+46*19.6078431, y:NOTE_Y1, lane:'L1' },
      { type:'tap', x:1680+50*19.6078431, y:NOTE_Y1, lane:'L1' },
      { type:'hold', x:1680 + 55*19.6078431, y:NOTE_Y2, lengthPx:8*19.6078431, lane:'L1' },
      { type:'hold', x:1680 + 63*19.6078431, y:NOTE_Y, lengthPx:4*19.6078431, lane:'L2' },
      { type:'tap', x:1680+72*19.6078431, y:NOTE_Y, lane:'L2' },
      { type:'tap', x:1680+79*19.6078431, y:NOTE_Y1, lane:'L3' },
      { type:'tap', x:1680+86*19.6078431, y:NOTE_Y, lane:'L2' },
      { type:'tap', x:1680+90*19.6078431, y:NOTE_Y2, lane:'L3' },
      { type:'tap', x:1680+95*19.6078431, y:NOTE_Y2, lane:'L3' },
      { type:'tap', x:1680+99*19.6078431, y:NOTE_Y1, lane:'L1' },
      { type:'tap', x:1680+104*19.6078431, y:NOTE_Y1, lane:'L1' },
      
    ]
  },
  song2: { id:'song2', title:'songname2 - DoubleLine', audioSrc:'audio/song2.mp3', NOTESPEED:15,
    notesData:[ {type:'tap',x:440,y:NOTE_Y,lane:'L1'}, {type:'tap',x:440,y:NOTE_Y2,lane:'L2'},
                {type:'tap',x:560,y:NOTE_Y,lane:'L1'}, {type:'tap',x:680,y:NOTE_Y2,lane:'L4'},
                {type:'tap',x:820,y:NOTE_Y,lane:'L3'} ] },
  song3: { id:'song3', title:'songname3 - Electro Bullet', audioSrc:'audio/song3.mp3', NOTESPEED:20,
    notesData:[ {type:'tap',x:500,y:NOTE_Y,lane:'L1'},{type:'tap',x:560,y:NOTE_Y,lane:'L1'},
                {type:'tap',x:620,y:NOTE_Y,lane:'L1'},{type:'tap',x:680,y:NOTE_Y,lane:'L1'},
                {type:'tap',x:740,y:NOTE_Y,lane:'L1'},{type:'tap',x:820,y:NOTE_Y,lane:'L1'} ] },
  song4: { id:'song4', title:'songname4 - Surreal 3-2', audioSrc:'audio/song2.mp3', NOTESPEED:15,
    notesData:[ {type:'tap',x:440,y:NOTE_Y,lane:'L2'}, {type:'tap',x:500,y:NOTE_Y2,lane:'L3'},
                {type:'tap',x:560,y:NOTE_Y,lane:'L2'}, {type:'tap',x:680,y:NOTE_Y2,lane:'L3'},
                {type:'tap',x:680,y:NOTE_Y,lane:'L2'}, {type:'tap',x:440+24*15,y:NOTE_Y,lane:'L2'}, 
                {type:'tap',x:500+24*15,y:NOTE_Y2,lane:'L3'},{type:'tap',x:560+24*15,y:NOTE_Y,lane:'L2'}, 
                {type:'tap',x:680+24*15,y:NOTE_Y2,lane:'L3'},{type:'tap',x:680+24*15,y:NOTE_Y,lane:'L2'},
                {type:'tap',x:440+48*15,y:NOTE_Y,lane:'L2'}, {type:'tap',x:500+48*15,y:NOTE_Y2,lane:'L3'},
                {type:'tap',x:560+48*15,y:NOTE_Y,lane:'L2'}, {type:'tap',x:680+48*15,y:NOTE_Y2,lane:'L3'},
                {type:'tap',x:680+48*15,y:NOTE_Y,lane:'L2'}, {type:'tap',x:440+72*15,y:NOTE_Y,lane:'L2'}, 
                {type:'tap',x:500+72*15,y:NOTE_Y2,lane:'L3'},{type:'tap',x:560+72*15,y:NOTE_Y,lane:'L2'}, 
                {type:'tap',x:680+72*15,y:NOTE_Y2,lane:'L3'},{type:'tap',x:680+72*15,y:NOTE_Y,lane:'L2'}] },
};

// --- helpers
function tailX(n){ return n.x + (n.lengthPx || 0); }

function cloneNotes(arr){
  return arr.map(n => {
    if (n.type === 'hold') {
      return {
        type:'hold', x:n.x, y:n.y, lengthPx:n.lengthPx||300, lane:n.lane||null,
        active:true,
        headConsumed:false,    // head was pressed/consumed
        headHit:false,         // head judged (for feedback)
        held:false,            // physical key currently down
        releasedEarly:false,   // released before tail
        tailConsumed:false,    // tail resolved
        invalid:false
      };
    } else {
      return { type:'tap', x:n.x, y:n.y, lane:n.lane||null, active:true, invalid:false };
    }
  });
}

// --- scoring UI
function initScoringForSong(arr){
  totalNotes = arr.reduce((a,n)=>a+(n.type==='hold'?2:1),0);
  basePoints = aceCount = missCount = 0;
  totalNotesEl.textContent = totalNotes;
  updateScoreUI();
}
function updateScoreUI(){
  const basePercent = totalNotes>0 ? (basePoints/totalNotes)*100 : 0;
  const bonusPercent = totalNotes>0 ? (aceCount/totalNotes)*1 : 0;
  basePercentEl.textContent = basePercent.toFixed(2) + '%';
  bonusPercentEl.textContent = bonusPercent.toFixed(2) + '%';
  totalPercentEl.textContent = (basePercent+bonusPercent).toFixed(2) + '%';
  aceCountEl.textContent = aceCount;
}

// --- judgement
function getJudgement(x){
  if (x >= (JUDGE_X - 12*NOTESPEED) && x < (JUDGE_X - 8*NOTESPEED)) return 'MISS';
  if (x >= (JUDGE_X - 8*NOTESPEED) && x < (JUDGE_X - 5*NOTESPEED)) return 'L-GOOD';
  if (x >= (JUDGE_X - 5*NOTESPEED) && x < (JUDGE_X - 1*NOTESPEED)) return 'L-PERFECT';
  if (x >= (JUDGE_X - 1*NOTESPEED) && x <= (JUDGE_X + 1*NOTESPEED)) return 'ACE';
  if (x > (JUDGE_X + 1*NOTESPEED) && x <= (JUDGE_X + 5*NOTESPEED)) return 'E-PERFECT';
  if (x > (JUDGE_X + 5*NOTESPEED) && x <= (JUDGE_X + 8*NOTESPEED)) return 'E-GOOD';
  if (x > (JUDGE_X + 8*NOTESPEED) && x <= (JUDGE_X + 12*NOTESPEED)) return 'MISS';
  return null;
}
function applyJudgement(j){
  let point = 0;
  if (j === 'ACE' || j === 'L-PERFECT' || j === 'E-PERFECT') point = 1;
  else if (j === 'L-GOOD' || j === 'E-GOOD') point = 0.5;
  else point = 0;
  if (j === 'ACE') aceCount++;
  if (point === 0) missCount++;
  basePoints += point;
  updateScoreUI();
}

// --- input / hold state
const laneHoldState = {}; // lane -> note currently held physically
const keyLastTime = {};
const PER_KEY_COOLDOWN_MS = 20;
const keysDown = new Set();

function handleKeydown(e){
  const code = e.code || e.key;
  if (e.repeat) return;
  const now = performance.now();
  if (keyLastTime[code] && (now - keyLastTime[code] < PER_KEY_COOLDOWN_MS)) return;
  keyLastTime[code] = now;
  if (keysDown.has(code)) return;
  keysDown.add(code);
  const lane = LANE_KEY_MAP[code] || null;

  // find nearest candidate (tap or hold head)
  let candidate = null, bestDist = Infinity;
  for (let i=0;i<notes.length;i++){
    const n = notes[i];
    if (!n || n.invalid) continue;
    if (lane && n.lane && n.lane !== lane) continue;
    if (n.type === 'hold'){
      if (!n.active || n.tailConsumed) continue;
      const dist = Math.abs(n.x - JUDGE_X);
      if (dist < bestDist){ bestDist = dist; candidate = n; }
      continue;
    }
    if (!n.active) continue;
    const dist = Math.abs(n.x - JUDGE_X);
    if (dist < bestDist){ bestDist = dist; candidate = n; }
  }

  if (!candidate) return;
  if (candidate.x < (JUDGE_X - 25*NOTESPEED) || candidate.x > (JUDGE_X + 25*NOTESPEED)) return;

  // TAP handling
  if (candidate.type === 'tap'){
    const j = getJudgement(candidate.x);
    candidate.active = false;
    if (j === 'MISS' || j === null){
      combo = 0; comboEl.textContent = combo;
      requestAnimationFrame(()=>showTemporaryText('MISS',900));
    } else {
      combo += 1; comboEl.textContent = combo;
      requestAnimationFrame(()=>showTemporaryText(j,900));
    }
    applyJudgement(j);
    return;
  }

  // HOLD head handling
  if (candidate.type === 'hold'){
    // if head already taken, just mark physical hold (allow re-press while holding)
    if (candidate.headConsumed){
      candidate.held = true;
      if (candidate.lane) laneHoldState[candidate.lane] = candidate;
      return;
    }

    const j = getJudgement(candidate.x);
    candidate.headConsumed = true;
    candidate.headHit = (j !== 'MISS' && j !== null);
    candidate.held = true;          // player is physically holding now
    candidate.releasedEarly = false;
    if (candidate.lane) laneHoldState[candidate.lane] = candidate;

    // Head judgement still gives feedback, but does NOT finish the hold
    if (!candidate.headHit){
      combo = 0; comboEl.textContent = combo;
      requestAnimationFrame(()=>showTemporaryText('MISS',900));
      applyJudgement('MISS');
    } else {
      combo += 1; comboEl.textContent = combo;
      requestAnimationFrame(()=>showTemporaryText(j,900));
      applyJudgement(j);
    }
  }
}

function handleKeyup(e){
  const code = e.code || e.key;
  if (keysDown.has(code)) keysDown.delete(code);
  const lane = LANE_KEY_MAP[code] || null;
  if (!lane) return;
  const heldNote = laneHoldState[lane];
  if (!heldNote) return;

  // if tail already resolved, just clear lane state
  if (heldNote.tailConsumed){
    if (laneHoldState[heldNote.lane] === heldNote) laneHoldState[heldNote.lane] = null;
    return;
  }

  // releasing before the tail passes is an early release -> mark held=false & releasedEarly=true
  heldNote.held = false;
  heldNote.releasedEarly = true;
  if (laneHoldState[heldNote.lane] === heldNote) laneHoldState[heldNote.lane] = null;
}

window.removeEventListener('keydown', handleKeydown);
window.removeEventListener('keyup', handleKeyup);
window.addEventListener('keydown', handleKeydown);
window.addEventListener('keyup', handleKeyup);

// --- visuals & loop
function forceShowMiss(){ combo = 0; comboEl.textContent = combo; requestAnimationFrame(()=>showTemporaryText('MISS')); }

function update(){
  const LEFT_MISS_MULT = 11;
  const leftMissLimit = JUDGE_X - LEFT_MISS_MULT * NOTESPEED;

  for (let i=0;i<notes.length;i++){
    const n = notes[i];
    if (!n) continue;

    if (n.type === 'tap'){
      if (!n.active) continue;
      n.x -= NOTESPEED;
      if (n.x <= 0 || n.x <= leftMissLimit){
        n.active = false; n.invalid = true; missCount++; forceShowMiss(); updateScoreUI();
      }
      continue;
    }

    // hold logic
    if (n.type === 'hold'){
      n.x -= NOTESPEED;

      // head never pressed and passed -> miss
      if (!n.headConsumed && n.x <= leftMissLimit){
        n.active = false; n.tailConsumed = true; n.releasedEarly = true; n.invalid = true;
        missCount++; forceShowMiss(); updateScoreUI();
        if (n.lane && laneHoldState[n.lane] === n) laneHoldState[n.lane] = null;
        continue;
      }

      // when tail crosses judge, resolve
      if (!n.tailConsumed && tailX(n) <= JUDGE_X){
        n.tailConsumed = true;

        // if head was never consumed -> miss
        if (!n.headConsumed){
          applyJudgement('MISS'); combo = 0; comboEl.textContent = combo; missCount++;
          requestAnimationFrame(()=>showTemporaryText('MISS'));
          if (n.lane && laneHoldState[n.lane] === n) laneHoldState[n.lane] = null;
          continue;
        }

        // SUCCESS only if the key is STILL physically held when tail passes
        if (n.held === true){
          applyJudgement('ACE'); combo += 1; comboEl.textContent = combo;
          requestAnimationFrame(()=>showTemporaryText('ACE',900));
        } else {
          applyJudgement('MISS'); combo = 0; comboEl.textContent = combo;
          requestAnimationFrame(()=>showTemporaryText('MISS',900));
        }

        if (n.lane && laneHoldState[n.lane] === n) laneHoldState[n.lane] = null;
      }
    }
  }
}

function draw(){
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  ctx.strokeStyle = "#fff"; ctx.lineWidth = 4;
  ctx.beginPath(); ctx.moveTo(JUDGE_X, HEIGHT); ctx.lineTo(JUDGE_X, 80); ctx.stroke();

  notes.forEach(n=>{
    if (!n) return;
    if (n.type === 'hold'){
      const tail = tailX(n);
      ctx.strokeStyle = '#4aa'; ctx.lineWidth = 6;
      ctx.beginPath(); ctx.moveTo(n.x, n.y); ctx.lineTo(tail, n.y); ctx.stroke();

      ctx.strokeStyle = n.active?'#fff':'#777'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(n.x, n.y, NOTE_RADIUS, 0, Math.PI*2); ctx.stroke();

      if (!n.tailConsumed){
        ctx.strokeStyle = "#fff"; ctx.beginPath(); ctx.arc(tail, n.y, NOTE_RADIUS-6, 0, Math.PI*2); ctx.stroke();
      }
    } else {
      if (!n.active) return;
      ctx.strokeStyle = "#fff"; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(n.x, n.y, NOTE_RADIUS, 0, Math.PI*2); ctx.stroke();
    }
  });
}

// loop
let combo = 0;
let running = false;
const TARGET_FPS = 30, FRAME_INTERVAL_MS = 1000/TARGET_FPS;
let lastFrameTime = performance.now();
function loop(){
  requestAnimationFrame(loop);
  const now = performance.now(), dt = now - lastFrameTime;
  if (dt < FRAME_INTERVAL_MS) return;
  lastFrameTime += Math.floor(dt/FRAME_INTERVAL_MS)*FRAME_INTERVAL_MS;
  if (running){ update(); draw(); }
}
lastFrameTime = performance.now();
loop();

// --- song select / start
const songsList = document.getElementById('songsList');
function createSongButtons(){
  Object.values(songs).forEach(s=>{
    const row = document.createElement('div'); row.className='songItem';
    const label = document.createElement('div'); label.textContent = s.title; label.style.flex='1';
    const btn = document.createElement('button'); btn.textContent='Play'; btn.onclick = ()=>selectSong(s.id);
    row.appendChild(label); row.appendChild(btn); songsList.appendChild(row);
  });
}
function showTemporaryText(text, ms=700){
  let popupEl = document.querySelector('.popup');
  if (popupEl) popupEl.remove();
  popupEl = document.createElement('div'); popupEl.className='popup'; popupEl.textContent=text;
  document.body.appendChild(popupEl);
  setTimeout(()=>{ if (popupEl) popupEl.remove(); }, ms);
}

function selectSong(id){
  const s = songs[id]; if (!s) return;
  musicEl.pause(); musicEl.currentTime = 0;
  NOTESPEED = s.NOTESPEED;
  notes = cloneNotes(s.notesData);
  initScoringForSong(notes);
  if (s.audioSrc) musicEl.src = s.audioSrc;
  combo = 0; comboEl.textContent = combo;
  running = true;
  currentSongEl.textContent = 'Loaded: ' + s.title;
  showTemporaryText('Loaded ' + s.title,700);
}

createSongButtons();
window.startSongById = selectSong;
</script>
</body>
</html>
