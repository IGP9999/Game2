<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Horizontal Rhythm Demo</title>
  <style>
    body { margin:0; background:#000; color:#fff; font-family: Arial, Helvetica, sans-serif; }
    #hud { padding:8px 12px; }
    canvas { display:block; margin:0 auto; background:#000; }
    .small { font-size:14px; color:#bbb; }
  </style>
</head>
<body>
  <div id="hud">
    <strong>Combo:</strong> <span id="combo">0</span>
    &nbsp;&nbsp;
    <span class="small">Click to start. Press any key to hit. Press R to restart.</span>
  </div>
  <canvas id="c" width="800" height="600"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const WIDTH = canvas.width;
const HEIGHT = canvas.height;

let combo = 0;
const comboEl = document.getElementById('combo');

// Judgment line and visuals
const JUDGE_X = 200;             // vertical line x position
const CIRCLE_Y = 350;
const RADIUS = 30;
const SPEED = 4;                 // pixels per frame (same as Python)
const SPAWN_XS = [440, 560, 680]; // initial X positions from your demo

// Note state: each note has x and active flag
let notes = [];
function resetNotes() {
  notes = SPAWN_XS.map(x => ({ x, active: true, judged: false }));
}

let running = false;

function reset() {
  resetNotes();
  combo = 0;
  updateHUD();
  running = false;
  drawScene();
}

function updateHUD() {
  comboEl.textContent = combo;
}

function drawScene() {
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  // background
  ctx.fillStyle = 'black';
  ctx.fillRect(0,0,WIDTH,HEIGHT);

  // judgment line
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 5;
  ctx.beginPath();
  ctx.moveTo(JUDGE_X, HEIGHT);
  ctx.lineTo(JUDGE_X, 100);
  ctx.stroke();

  // draw notes
  for (const n of notes) {
    if (!n.active) continue;
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.arc(n.x, CIRCLE_Y, RADIUS, 0, Math.PI*2);
    ctx.stroke();
  }
}

function step() {
  for (const n of notes) {
    if (!n.active) continue;
    if (n.x > 100) {
      n.x -= SPEED;
    }
    if (n.x <= 100) {
      n.active = false; // passed left edge, disappear
      n.judged = true;  // treat as judged (miss)
      combo = 0;
      updateHUD();
    }
  }
}

function frame() {
  if (!running) return;
  step();
  drawScene();
  requestAnimationFrame(frame);
}

// Find nearest unjudged active note (anywhere) and apply Python's ranges based on its x
function judgeNearest() {
  // find nearest active and not judged
  let best = null;
  let bestDist = Infinity;
  for (const n of notes) {
    if (!n.active || n.judged) continue;
    const dist = Math.abs(n.x - JUDGE_X);
    if (dist < bestDist) { bestDist = dist; best = n; }
  }
  if (!best) return;

  // Only allow hits when note is within the original hittable window 100..300
  const x = best.x;
  if (!(100 <= x && x <= 300)) {
    // outside hittable window -> consume and miss
    best.active = false;
    best.judged = true;
    combo = 0;
    updateHUD();
    return;
  }

  // consume on any key press
  best.active = false;
  best.judged = true;

  // replicate your Python judgment ranges exactly
  if (100 <= x && x < 136) {
    console.log("MISS");
    combo = 0;
  } else if (136 <= x && x < 176) {
    console.log("L-GOOD");
    combo = combo + 1;
  } else if (176 <= x && x < 192) {
    console.log("L-PERFECT");
    combo = combo + 1;
  } else if (192 <= x && x <= 208) {
    console.log("ACE");
    combo = combo + 1;
  } else if (208 < x && x <= 224) {
    console.log("E-PERFECT");
    combo = combo + 1;
  } else if (224 < x && x <= 256) {
    console.log("E-GOOD");
    combo = combo + 1;
  } else if (256 < x && x <= 300) {
    console.log("MISS");
    combo = 0;
  } else {
    combo = 0;
  }
  updateHUD();
}

// any key -> judge nearest
window.addEventListener('keydown', (e) =>
